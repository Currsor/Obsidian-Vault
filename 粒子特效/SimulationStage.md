[参考链接](https://zhuanlan.zhihu.com/p/339468114)
## 粒子更新(**ParticleUpdate**)
一般来说，我们粒子系统的核心逻辑都会放到ParticleUpdate里，极少数可能在EmitterUpdate中，其他都是一些初始化的内容。可以说Update是核心，我们需要在这个每帧执行一次的段落中，更新所有粒子的位置、速度、颜色等等各种状态，从而实现效果随时间的演变。
### 顺序
假如我们有A、B、C三个待执行的内容，那么在一个粒子系统中，系统会先对粒子1依次执行ABC，之后对粒子2依次执行ABC，直至最后一个粒子执行完毕，ParticleUpdate才算正式结束，执行从上至下进入下一个大的栏目中。
### 局限
Niagara中能随时获得其他任何一个粒子的属性（通过AttributeReade)，并根据这些属性做出计算，但是由于并行运算的复杂调度，以及我们无法控制每个粒子的先后执行顺序带来的不确定性，实际上我们是缓冲了上一帧的计算结果来进行属性的读取，即整个ParticleUpdate过程中发生的所有的使用AttributeReader进行的属性读取，**都是当前帧的初始值**。假如粒子1经过A运算后，属性发生了改变，粒子2想要在B运算时获得粒子1改变后的属性，是不可能做到的。

上述获得前一帧粒子属性的限制，只发生在相同Emitter下使用AttributeReader的属性读取。跨Emitter的粒子属性读取，是会在生成代码时自动分析这种依赖关系带来的执行先后顺序，从而保证我们读取到的是**当前帧执行后的粒子属性**。

## **SimulationStage**
在同一帧下我们希望所有的粒子先同时执行A，等所有粒子执行完A之后，每个粒子的属性发生了相应改变，我们再利用这些改变后的属性执行B。当所有ABC执行完毕后，我们才希望更新当前帧的粒子的表征，如位置颜色等，此时我们就必须要用到SimulationStage来实现。

我们可以往一个Emitter中添加多个SimulationStage。概念上讲，每个SimulationStage相当于是一个执行的同步等待点。每个SimulationStage做着同ParticleUpdate类似的事情，能应用到ParticleUpdate中所有可以使用的模块。
## 缺点
假如我们的逻辑不需要这样的等待过程，使用ParticleUpdate也能正常完成，那么SimulationStage带来的等待必然会产生一些性能上的损失，因此不是在任何的情况下都需要SimulationStage来介入。只有在我们的逻辑对当前帧其他粒子的属性或某些中间阶段性的结果有强的顺序依赖时，才需要SimulationStage。

## 中间缓存
引入SimulationStage之后还没有解决一个核心的问题，那就是我们读取其他粒子的属性还是只能通过AttributeReader，而它在SimulationStage中读取的同样是上一帧的粒子属性，因为缓存每个阶段所有粒子的属性中间值是不那么高效与优雅的，会浪费很多的资源。

我们需要这一容器在当前帧的任一SimulationStage都是可在任意位置读写的，于是我们的[[Grid2D]]、[[Grid3D]]等等内容就登场了。
### 基础用法
点击任意一个Emitter的属性后的加号，在详情页中点击常规模拟阶段.
##### 迭代源
默认情况下它是粒子，即我们对所有粒子进行遍历，而数字迭代为1说明我们遍历一次。

迭代源可以替换成数据接口,它是我们所有中间数据结构的统称。
其中数据接口中我们可以指定所有在Emitter中创建的中间数据结构变量。
执行行为中的模拟重设时是用来指定当前SimulationStage是否为初始化时执行，即只在Emitter激活后的第一帧执行唯一一次。