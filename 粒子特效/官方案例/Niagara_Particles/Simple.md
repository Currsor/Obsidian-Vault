# 1.1

这里创建的属性可以被系统中的所有其他发射器和粒子访问，因为数据从system>emitter ->particles流动。
___
# 1.2

`Initialize Particle`中初始化这个发射器粒子的生命周期，颜色，大小等属性。

#Niagara节点`Initial Mesh Orientation`初始化网格体方向
模块使用位掩码：粒子生成脚本
 
![[Pasted image 20240627222352.png]]
网格方向模式选择了`指向矢量Mesh Orientation Mode`，这意味着将移动方向设置为`网格体轴指向Mesh Axis To Orient`


#Niagara节点`Update Mesh Orientation`更新网格体方向
模块使用位掩码：粒子更新脚本

![[Pasted image 20240627223428.png]]
___
# 1.3

光渲染器和带状渲染器目前仅用于CPU
GPU渲染优势在于可以更好的渲染大量粒子，但会较为不精确。

1. **PARTICLE脚本**（绿色部分）：
    
    - **Spawn（生成）和Update（更新）部分**：这些脚本负责处理粒子的生成和更新，这些操作是在GPU（图形处理单元）上执行的。GPU是专门为高并行计算而设计的，非常适合处理大量粒子，因为它们可以同时更新许多粒子。
2. **System和Emitter脚本**（橙色和蓝色部分）：
    
    - **System（系统）和Emitter（发射器）脚本**：这些脚本在CPU（中央处理单元）上执行。CPU是通用处理器，适合执行复杂的逻辑和串行任务。系统脚本可能负责管理粒子系统级别的行为，而发射器脚本则控制粒子的发射。
    - 这些脚本被限制为只能执行“CPU友好”的操作，意味着它们不能执行需要GPU强大并行处理能力的任务，如纹理采样或场景距离场的查询。\


#Niagara节点 `Spawn Rate`
模块使用位掩码：发射器更新脚本

![[Pasted image 20240628100655.png]]
以一定速率不断生成粒子


#Niagara节点 `Spawn Burst Instantaneous`
模块使用位掩码：发射器更新脚本

![[Pasted image 20240628100858.png]]
一瞬间产生一束粒子


#Niagara节点 `Curl Noise Force`
模块使用位掩码：粒子更新脚本

![[Pasted image 20240628101932.png]]
**可能是最常用和最好用的随机力场**


#Niagara节点 `Point Attraction Force`点引力
模块使用位掩码：粒子更新脚本

![[Pasted image 20240628102424.png]]
顾名思义就是以以一个点对粒子进行吸引，如果引力过大可能导致粒子在吸引点附近来回弹，可以使用`Kill Radius`进行避免
___
# 1.4

#Niagara节点 `Sprite Facing and Alignment`
模块使用位掩码：粒子更新脚本

在Sprite渲染器中，将面向或对齐方式设置为“自定义”允许使用这些向量来控制Sprite的方向。默认情况下，渲染器属性绑定到Particles.SpriteFacing（Sprite面向）和Particles.SpriteAlignment（Sprite对齐）。如果此模块在发射器脚本中使用，它将设置这些属性的发射器版本，以便在将精灵源模式设置为“Emitter”时使用。

- 对齐（Alignment）是贴图y轴的方向；
- 朝向（Facing）是Sprite法线的方向；

精灵面向和对齐始终是世界空间向量，因此我们在使用局部空间时提供了一些默认转换，这些转换可以被重写。


#Niagara节点 `Vortex Velocity` 
模块使用位掩码：粒子更新脚本

![[Pasted image 20240628153010.png]]
绕`Vortex Origin`进行旋转
___
# 1.5

![[Pasted image 20240628153857.png]]

暂态变量（Transient variables）仅限于特定的堆栈上下文（例如粒子更新），并且每帧都会重新计算，它们不会在帧与帧之间保留值。这使得它们与粒子变量（Particle variables）不同，后者保存在粒子有效载荷中，并且从一帧到下一帧持续存在，这会带来内存和性能的开销。
在这里，我们创建一个代表当前距离发射器原点的暂态变量，并使用它来驱动颜色和缩放曲线。
这意味着，对于每个粒子的每一帧，都会根据粒子的当前位置重新计算其与发射器原点的距离，并使用这个距离值来影响粒子的颜色和大小。因为暂态变量不存储在粒子上，所以它们不会增加粒子的存储成本，但它们需要每帧计算，这可能会影响性能。这种机制允许动态地根据粒子的状态改变其外观，而无需为每个粒子存储额外的信息。
___
# 2.1

条带渲染
使用RibbonID链接起来的粒子构成条带
使用`Beam Emitter Setup`设置起点终点以及其中转弯处的切线
使用`Spawn Burst Instantaneous`生成粒子

RibbonLinkOrder 变量用于指定带状粒子之间的连接方式。当使用生成光束模块时，新产生的粒子会根据它们的生成顺序被分配一个 RibbonID，这个 ID 用于确保粒子在模拟过程中保持独立的带状结构，而不是全部连接成一个大的带状结构。这样，每个光束都可以保持自己的形状和动态，而不会与其他光束混合。由于 RibbonID 和连接顺序在帧与帧之间保持不变，因此每个光束都能够稳定地维持其形状和结构。

#Niagara节点 `Spawn Beam`
模块使用位掩码：粒子生成脚本

它会在贝塞尔样条曲线或两点之间的直线上放置粒子。对于沿射线路径排列精灵很有用，也可以与带状渲染器一起使用，以创建经典的射线效果。创建射线会创建一个静态射线，不会在每个帧重新计算起点和终点。


#Niagara节点 `Beam Width`
模块使用位掩码：粒子生成脚本

控制生成射线的宽度，并将其写入`Particles.RibbonWidth`中。使用从默认生成射线模块中提供的曲线索引来沿射线长度改变宽度，该曲线是基于射线链接顺序的。
___
# 2.2

核心思想就是使用`RibbonLinkOrder`，这是每个形成条带的粒子的ID

#Niagara节点 `Rotate Around Point`
模块使用位掩码：粒子更新脚本

![[Pasted image 20240629211540.png]]
这个中使用`RibbonLinkOrder`,先是于RotationPhase中将其与旋转偏移量进行关联

在半径的设置中使用曲线以及`RibbonLinkOrder`来控制螺旋的形状
___
# 2.3

在一个发射器中可以使用多个渲染器

设置颜色等大多数是在各个模块中设置，但你可以自己新建一个变量然后给相应的渲染器进行绑定，然后堆栈中进行设置
![[Pasted image 20240629212500.png]]
___
# 2.4

==目前事件仅限于CPU使用==

#Niagara节点 `Generate Location Event`生成位置事件
Event Generators 是指在粒子系统中生成特定事件的功能，比如“Generate Location Event”（生成位置事件）。在粒子脚本中，这类事件生成器默认==在求解器运行后==发送位置事件，以保证最高的精确度。但这个模块可以根据需求被放置在脚本的任何位置，以决定何时发送事件。

“Send Rate”（发送速率）通常被设置为一个合理的每秒事件数，但这个值可以降低以减缓事件的发送速率，作为一种优化手段。如果取消勾选“Event Send Rate”（事件发送速率）旁边的复选框，事件将会在每一帧都被发送。


事件接收器需要一个额外的脚本，称为“事件处理程序”。你可以将其视为另一个脚本，比如粒子生成或更新脚本，它在接收到事件后运行。这个脚本需要包含一个“接收X事件”模块来处理事件，然后可以在其中放置其他模块，以对收到事件的粒子产生额外效果。
___
# 2.5

表达式使用的是HLSL
使用表达式直接设置参数
___
# 2.6

碰撞检测既可以在CPU发射器上运行，也可以在GPU发射器上运行，不过有些选项是不同的。例如，只有GPU发射器可以对场景深度或全局距离场进行采样。

一般来说，与GPU碰撞相比，CPU碰撞是相当昂贵的，应该谨慎使用。

碰撞可以选择使用`Generate Collision Event`(生成碰撞事件)模块生成事件。这些仅在CPU上支持。
___
# 3.1

#Niagara节点 `Sraric Mesh Location`
可以采样静态网格体，获取上面的点位置以及颜色旋转等，以此生成粒子
___
# 3.2
使用了新的参数然后进行了一定的偏移然后绑定给了sprite渲染器

___
# 3.3

可以使用渲染器可视性标签来控制显示的渲染器
![[Pasted image 20240630160110.png]]

可视性中的渲染器可视性就是其的可视性标签

可以动态调整标签以达到物体不断切换的效果
___
# 3.4

==纹理采样目前只支持GPU==

#Niagara节点 `Grid Location`
对网格进行采样，可以看作UV

在`Kill Particles`中设置Alpha值为0的粒子在第一帧删除
![[Pasted image 20240630161111.png]]
在粒子系统中，"Kill Particles"模块通过采样纹理，并基于采样纹理的alpha（透明度）值来决定是否销毁新产生的粒子。如果alpha值为0，那么粒子在其第一帧就会被销毁，从而有效地从模拟中移除。
在发射器属性中的"Interpolated Spawn"（内插生成）选项决定了粒子的生成和更新方式。当"Interpolated Spawn"未勾选时，新产生的粒子在其出生帧只会运行它们的更新脚本，而不会运行生成脚本。这意味着粒子的初始属性（如位置、速度和生命周期）是在第一帧确定的，然后在后续帧中按照这些属性进行更新。
由于"Kill Particles"模块只在粒子的生命周期的第一帧操作，并且在后续帧不需要任何额外的处理，所以它在计算资源方面是非常经济的。这使得它成为一种高效的方式来控制模拟中粒子的密度和分布，通过利用存储在纹理中的信息来实现。
___
# 4.1

==目前，从粒子播放音频只支持在CPU上==

#Niagara节点 `Play Audio`
播放音频
其中有许多播放模式，如死亡时播放
可以通过控制布尔值来控制音频的播放
___
# 4.2

在Sprite和Mesh渲染器中，有一个名为“Source Mode”（源模式）的属性。当设置为“Emitter”（发射器）时，渲染器可以创建一个由发射器脚本驱动的单一精灵/网格，而不是粒子脚本。所有的绑定都会从粒子绑定更改为发射器命名空间绑定，例如，Emitter.Position（发射器位置）驱动世界中的位置，而不是Particles.Position（粒子位置）。
粒子的生命周期由发射器状态的生命周期控制，发射器级别的曲线会自动由Emitter.NormalizedAge（发射器标准化年龄）索引，这使得按生命周期缩放事物变得容易。
查看精灵渲染器的“bindings”（绑定）部分，看看当选择“Emitter”（发射器）设置时，它们各自变成了什么。
在选择“Emitter”设置时，精灵渲染器的“bindings”部分通常会有以下变化：
1. **Position** - 由Particles.Position变为Emitter.Position，这意味着精灵的位置将由发射器的位置决定，而不是单个粒子的位置。
2. **Rotation** - 由Particles.Rotation变为Emitter.Rotation，精灵的旋转将基于发射器的旋转。
3. **Scale** - 由Particles.Scale变为Emitter.Scale，精灵的缩放将基于发射器的缩放。
4. **Color** - 由Particles.Color变为Emitter.Color，精灵的颜色将基于发射器的颜色。
5. **UVs** - 由Particles.UV变为Emitter.UV，精灵的纹理坐标将基于发射器的纹理坐标。
这些变化意味着所有的属性和行为都将由发射器控制，而不是每个粒子的独立控制。这对于创建由发射器控制的单一实体（如角色或物体）的动画和行为非常有用。


这种设置是一种优化。当只需要一个单一的精灵渲染器而不是在N个粒子上的多个精灵时，可以减少粒子脚本逻辑的执行。例如，如果只需要在特效中心创建一个单一的光晕效果，就可以使用这种优化。
通过将精灵渲染器的源模式设置为“Emitter”，可以避免为每个粒子执行复杂的脚本逻辑。相反，所有的行为和属性都由发射器控制，这意味着只需要处理一个渲染器，而不是每个粒子的渲染器。这样可以显著减少CPU和GPU的负载，提高性能。
这种优化特别适用于那些不需要大量粒子或每个粒子独立行为的情况，例如，渲染一个始终位于发射器位置的中心光晕，或者一个不随粒子移动的静态背景图像。通过这种方式，可以创造出视觉效果丰富且性能高效的粒子效果。

这种设置在使用高级模拟阶段特性时也非常有用，该特性允许将数据网格写入渲染目标，例如实时流体模拟。在这种情况下，流体模拟是在一个2D网格集合上计算的，然后导出到一个渲染目标，并通过一个面向单一相机视角的精灵或网格上的材质进行渲染。
使用"Emitter"源模式的优势在于：
1. **性能优化**：由于只有一个精灵或网格渲染器被用于显示模拟结果，而不是为每个网格单元创建一个粒子，因此可以大幅减少渲染调用和CPU/GPU的计算负担。
2. **简化的数据流**：将模拟数据直接写入渲染目标，然后通过材质进行处理，可以简化数据流并减少在GPU和CPU之间传输数据的需求。
3. **灵活的视觉效果**：通过在材质中处理渲染目标数据，可以应用各种后处理效果，如模糊、颜色调整、亮度对比度等，以创造出更加丰富和逼真的视觉效果。
4. **动态模拟**：由于渲染目标是动态更新的，因此可以实时反映模拟状态的变化，例如流体流动、烟雾扩散等。
5. **易于控制**：通过控制渲染目标的分辨率和更新频率，可以轻松地调整模拟的细节水平和性能开销，以适应不同的硬件和性能要求。
总之，"Emitter"源模式在需要将粒子系统与复杂模拟或视觉效果结合时，提供了一种高效且灵活的解决方案。它不仅优化了性能，还提供了更多的创造空间，使得开发者能够创造出更加丰富和动态的视觉体验。
___
# 4.3

直接定向模块（初始网格定向、更新网格定向）使用“直接设置”方法来处理网格发射器的定向。它们直接分配一个定向值，该值创建一个恒定的旋转速率，与网格粒子的尺寸或质量无关。
在这个例子中，可以看到粒子无论大小/质量如何，总是以相同的恒定速度旋转。可以将其视为一个恒定的“旋转率”。
这种方法是一种低成本的解决方案，并且让用户能够根据粒子的年龄或其他指标直接控制旋转。
在这个模型中，旋转阻力（拖曳模块上的一个选项）没有效果。


网格旋转力模块是基于力的旋转系统，它采用更物理的方法来处理旋转。"Mesh Rotation Force"（网格旋转力）和"Drag"（阻力）结合使用，创建了一个基于力的模型，其中质量和旋转惯性被纳入最终的旋转值中。
这个模型依赖于为每个粒子设置质量，然后我们通过使用"Calculate Size by Mass"（根据质量计算大小）模块套件，从质量值推导出网格缩放。注意，这个模型需要设置"Initial Model Dimensions"（初始模型尺寸），这是导入时网格的尺寸，可以通过在内容浏览器中悬停在网格缩略图上来找到。
我们仍然在生成时直接设置一个初始定向，但在更新时我们应用一个力，以及旋转阻力，然后我们允许它们通过一个特殊的求解器进行积分。
注意，在这个模型中，较大的网格旋转较慢，因为它们具有更高的旋转惯性，阻力对旋转速度有影响，等等。
这个模型在计算上更昂贵，但在希望较大粒子对刺激响应更真实的情况下，它可以创造出令人满意的结果。


旋转力会累积到Particles.RotationalVelocity（粒子旋转速度）变量中，并从一帧持续到下一帧。在这里，我们通过应用旋转力并然后将这些力应用到旋转速度上，给粒子一个初始的“踢力”。我们使用这种方法，因为它将质量纳入初始旋转速度中。
然后，这些在更新阶段由求解器解决，旋转阻力最终会减慢粒子的速度。
如果你希望初始“踢力”不考虑质量因素，可以使用“Add Rotational Velocity Module”（添加旋转速度模块）来直接在粒子生成时设置一个旋转速度。
