## [[材质实例]]
## **纹理与材质：**
材质：一个完整的材质通常包含5种纹理，它分别是基本颜色（color）、法线（normal）、环境光遮蔽（AO）、粗糙度（roughness）和金属度（metalness）。

**基本颜色**：基本颜色它记录了材质表面的颜色。
**法线**：法线记录了材质表面的法线信息。并将法线信息转化为光影下表现出的凹凸感。
**环境光遮蔽**：记录了模型表面的光线遮蔽效果（这种遮蔽效果通常是自我的遮蔽）。
**粗糙度**：记录了材质表面的粗糙度信息。越白，就意味着这个地方粗糙度越高。反之亦然。
**金属度**：金属度记录了材质金属质感的强度。如果这个地方越白，那么就意味着这个地方金属质感越强。

## **纹理命名规范：**
大多数情况下纹理我们通常使用"T_"作为前缀（Texture）
颜色纹理：T_BaseColor 或T_Color
法线纹理：T_Normal 或T_N
环境光遮蔽：T_AmbientOcclusion 或T_AO
粗糙度纹理：T_Roughness 或T_R
金属度纹理：T_Meatallic 或T_M
## 标准纹理尺寸：
纹理尺寸：支持标准分辨率，满足2的N次幂的数字比如：1x1、2x2、32x32、512x512、1024x1024、2048x2048、4096x4096等等。
纹理的比例：可以是非正方形，但要满足是2的N次幂的数字如：64x256、512x128、1024x2048、16x1024等等。
## **Mipmap**
非标准的纹理也可以在材质中正常使用，但是一般都不会使用这种非标准的纹理。因为这种非标准纹理，在摄像机距离稍微远的时候，会发生闪烁影响观感。

为什么标准纹理尺寸不会出现像非标准纹理尺寸一样的闪烁，原因是一种叫做Mipmap多级渐进式纹理算法。这种算法为纹理生成逐级缩小2倍的纹理，优化性能与远距离的视觉表现。 当相机距离较远时，使用较低的层级。
## **纹理压缩**
所有导入UE4引擎里的纹理贴图都会被压缩，不管它之前的体积有多大，导入到UE4以后同样的压缩率，同样的分辨率下，图像的大小都是一样大的。

第一个默认选项“**默认**”（Default）。普通贴图导入进来都会默认选择这个压缩方式。

第二个默认选项“**法线**”（Normalmap）顾名思义，就是我们法线贴图的压缩选项，只要我们的贴图是法线贴图，我们必须要是这个格式，不然这张贴图是没有办法在引擎中正常使用的。

第三个默认选项“**遮罩**”（Masks）是我们遮罩用途的纹理贴图选项，如果我们使用的是一张纹理贴图的灰度，那么我们就可以选择这个Masks压缩模式，如果你在默认压缩选项中==勾选取消sRGB==也能达到同样的效果。

第四个选项“**灰度**”（Grayscale），如果我们的贴图只包含一个通道，也就是说整体只有一个灰度信息，那么我们可以使用这一个格式进行压缩。需要注意的是这个选项并不会对纹理进行太多的压缩或者说是不压缩。如果你需要一个非常高质量的灰度图可以选择这个选项，这样贴图的体积就会大一些。

第五个选项“**置换贴图**”（Dispacementmap）,顾名思义，这是置换贴图专用的压缩格式，可以看到后面有个16位。如果==使用高质量的置换贴图==就可以使用这个选项。

第六个选项“**向量置换贴图**”（VectorDispacementmap），向量置换贴图是一个比较特殊的纹理，在这种纹理，它是类似于法线贴图三个维度XYZ储存信息的，但是储存的信息是类似于HDR中是高动态范围32位的信息。所以我们需要使用这个纹理，我们就可以使用这个选项，这个压缩之后的贴图体积算是比较大的。

第七个选项“**环境光贴图**”（HDR），环境光贴图也算是比较常用的32位高动态范围信息的贴图，所以这个格式中贴图的体积也是比较大。

第八个选项“**用户界面信息2D**”（UserInterface2D）,也就是我们俗称的UI界面贴图。

第九个选项“**透明度**”（Alpha），透明度压缩模式类似于上面的遮罩Masks模式，如果我们的纹理贴图是一张透明度贴图Alpha，那么我们可以使用这种格式，这种压缩格式会比灰度Grayscale压缩后的体积要小一些。通常在特效透贴纹理使用。

第十个选项“**距离场字体**”（DistanceFieldFont）也可以看做成矢量字体。在字体缩放较大的情况下,字体失真严重。但是距离场字体的纹理体积较大，比较占用内存。

第十一选项“**压缩HDR**”（HDRCompressed ）一种可压缩的HDR格式，体积比上诉HDR格式要小，但是相应纹理细节损失也会有一些。

第十二选项“**默认（BC7）**”BC7是虚幻引擎中最高质量的纹理格式，所以这个格式压缩后的文件体积是最大的。所以这种压缩格式通常在我们需要表现非常高质量的细节的时候才会使用这种格式。
## 纹理通道
纹理图像是由RGB三个通道混合而成，它们的亮度记录了该通道的颜色多少。纹理图像还包含了A通道，记录图像的透明度，但在UE4引擎中，它并不一定指的是透明度，你可以指定任何纹理。
在这四个通道里面，不仅仅可以塞一些遮罩，我们可以在RGB通道里分别塞入，金属度，粗糙度，AO，置换贴图等等一些只有灰度的纹理图像，这样做可以小幅度优化性能减少采样次数。通常我们并不会塞入A通道反而是把A通道删去，因为在UE4游戏引擎里==A通道的体积较大==，所以我们只需要RGB通道即可。
如果你的三个通道都塞入了一些灰度图纹理，命名方式也要按照RGB的顺序来表示分别塞入了什么纹理，比如R通道：粗糙度，G通道：金属度，B通道：AO。所以我们通常命名为“T_RMAO”。如果B通道为置换贴图，那么我们可以命名为“T_RMD”等等。
Alpha通道会占用我们很大的一部分贴图体积，有的甚至会增加十倍以上的文件体积。这是非常不划算的。这是因为我们的RGB通道会被压缩，而Alpha通道在UE4里面压缩率是比较低的，所以文件体积会比较大。所以不建议大家用Alpha通道来储存一些并不重要的贴图，不如存放在RGB通道里。如果是非常重要的贴图，比如说带渐变的半透明，或者其他比较复杂细节要求比较高的半透明遮罩等等可以把它们放进A通道。
## sRGB与伽马矫正
Gamma矫正，以还原人眼的效果。矫正会把图像暗处变得更亮，灰度图同样会变得更亮。如果是粗糙度，那么就会出现比岩本更粗糙的效果，如果是金属度，则会获得更多的金属质感。
在UE4中，默认勾选了sRGB选项，它用来反Gamma矫正（≈^2.2），回到图片原本的样子。但是我们的灰度图并没有呗Gamma矫正过，执行反矫正就会使整体更黑得到错误的灰度图信息。
==所以我们如果使用的是图片的灰度信息，那么我们应该取消掉“sRGB”选项，或者将压缩模式设置为“Mask”，来得到正确的图片灰度信息。==
为什么颜色贴图不用sRGB反伽马矫正，是因为颜色贴图是给人看的，所以不用关闭sRGB。而粗糙度，金属度，AO等等灰度图纹理，是用机器算法读取的，每一个数值的变化都会产生最终效果的变化，所以要取消srgb来还原最正确的灰度效果。 ^9659bb
## **前向渲染**
前向渲染会对场景里每一个几何体进行光栅化，就需要对每一个几何体计算场景所有的灯光来得到它们正确的光影材质表现。它进行深度测试，把被遮挡的多边形进行剔除.每个几何体都需要计算所有灯光，那么计算量将会非常的大
深度检测:
	**距离剔除** ：相机渲染距离往往不是无限远的，在渲染时，超出距离的模型会被剔除掉，不进行渲染。距离剔除消耗是非常低的，因为计算物体和相机的距离的计算过程，是几乎没有消耗的。所以说距离剔除消耗最低，所以会被最先计算，我们会把消耗最低的方式放在最前面。
	**视锥剔除**：相机的渲染时类似于金字塔的锥形范围，超出锥形范围的模型会被剔除掉。视锥检测会比距离检测消耗稍高。所以会放到距离剔除之后计算。
	**遮蔽剔除**：检测每一个模型的可见性，相对高消耗的剔除检测，所以它通常在最后执行。因为在这之前的剔除操作已经剔除了很大一部分模型，检测模型可见性的工作量就会降低。以上的剔除都是引擎自动完成的，距离剔除需要手动设置，在UE4中还能烘焙预计计算可视性数据。
	**深度测试**：以上步骤只能剔除完全不可见或者完全被遮挡的物体，那么对于半个被遮挡的物体，可以通过深度测试来剔除几何体上一部分像素。比如两个物体重叠，那么我们就可以通过深度来判断，哪一个像素在前哪一个像素在后，然后我们把靠后的像素剔除掉。让它不会出现遮挡处的透视效果。
## 延迟渲染
延迟渲染增加了一个G-Buffer缓存，G是Geometry几何体的意思，几何体的深度检测会先被执行，再把各种数据光栅化到这个缓存区里，在这里它不会计算光照。
**前向渲染会渲染被遮挡的模型造成资源的浪费，但是延迟渲染会先生成G-Buffer占用大量的带宽**。
## **半透明材质**
G-Buffer缓存会先进性几何体深度测试，在进行光照计算完成光栅化，那么也就是说实际上半透明表现时有问题的，因为被遮挡的物体已经被深度检测剔除掉了，而半透明需要知道背后的像素什么，所以半透明需要单独对待，不能进行深度测试。这也就是为什么在延迟渲染中半透明实现起来非常困难的原因。

UE4中可以单独为半透明材质开启前向渲染功能，这是一个非常高消耗的材质类型，无法完成深度检测，所以也会出现半透明物体的渲染排序问题。
## [[UE--材质常用节点]]
## 材质实例
材质实例的作用就是，我们可以制作几个少量的但是功能比较通用的主材质，主材质可以添加非常多的参数化的可控制的节点开放给面板供我们调试。然后在主材质的基础上我们可以创建非常多的材质实例，分别赋予给不同模型，然后每个材质实例的参数互相独立以达到同样材质不同效果表现的效果，我们可以省下大量的性能和材质编译的时间。
## **纹理采样**
如果我们把贴图拖进材质蓝图中，就可以直接使用。比如我拖进去一张基本颜色贴图，直接可以连接到材质上的基本颜色上。
实际上我们看节点名称“Texture Sample”纹理采样，它并不是我们所理解的纹理，我们点击这个节点可以在预览窗口下方细节面板中的材质表达式纹理的窗口看到指定了一张纹理。
我们右键“Texture Sample”把它转化为纹理对象。纹理对象才是真正意义上的纹理，但是纹理对象是不能直接连接到材质上的。也就是说我们的纹理需要被纹理采样采样后才能正确的被使用。我们的UE4引擎在我们拖入一张纹理的时候，会自动的把纹理放入到纹理采样里面。
完整的纹理采样过程，需要输入一个纹理，同时要输入一个UV坐标，我们可以摁下快捷键“U”来创建“TexCoord”纹理坐标。所以纹理需要被纹理采样器采样后才能使用，这是一个基本的纹理采样节点连接方式，在UE4引擎中拖入纹理会自动简化这个步骤。
## UV
纹理坐标节点决定了如何对纹理进行采样，它默认输出的是XY轴的0~1。需要注意的是在UE4中，纹理坐标的原点是在**左上角**。
![[v2-b53f27d8a99fa34d60b8891f54310cf7_720w.webp]]如图我们导入一张0到9的一张纹理贴图，为了能直观的看到UV坐标参数的修改，我使用了Mask节点进行拆分，然后用Append节点进行合并，最后输出到基本颜色进行预览观察。

例如我们可以利用纹理坐标节点，修改XY轴的大小来让纹理输出我们想要的区域，如果我们只输出贴图中0~9数字中的0的话，那么我们可以看到纹理中横4个数字，竖着有3个数字。![[v2-46177626ee851dcd8b6007dcffa29d2e_720w.webp]]
我们只要修改纹理坐标的XY轴修改为“X：0.25 Y：0.333”，就可以输出纹理中的0。

如果我们想把贴图左右镜像的话也很简单，只要把UV坐标的X轴给反向即可，这里我们会使用一个新的节点，叫**反向“OneMinus（1-x）”**![[v2-e305d90f26e00e58fe39adf024b9fd50_720w.webp]]
### **UV的平移缩放**
如果我们想让纹理进行X轴的平移，那么我们只要修改纹理坐标节点中的U坐标即可，所以我们先把纹理坐标用Mask节点进行拆分然后在U坐标上增加一个add节点
如果我们想自动平移的话，可以用我之前文章讲到过的Time节点。我们把time节点进行取小数，然后让纹理坐标节点中的X轴加上这个时间即可
如果觉得这样速度没有办法控制，我们可以增加一个速度控制节点

在UE4材质蓝图中有一个已经封装好的自带的**平移节点“Panner”**
panner节点自带xy轴的控制，并且可以用一个1维向量转化为参数开放给材质实例面板来方便的修改速度。
### **UV坐标的缩放**
把UV坐标给独立出来拆分，并且分别XY轴加上0.5把我们的图标给移到中间：![[v2-bbb691b7b9fd1e09945f1a1e190eac60_720w.webp]]
如果我们不需要周围有重复的纹理，那么我们只要点击纹理采样，![[Pasted image 20231103194203.png]]在材质表达式纹理采样中修改采样器源为限制.这样纹理的采样就会变成（0~1）之间，而大于1的纹理直接会舍去。但是看到我们输出的贴图是在右上角，那是因为我们UV采样的范围是（0.5~2.5）所以只有右上角是在（0~1）区间内，这个时候我们把UV采样反过来给减去0.5，这样采样区间就会在（-0.5~1.5）之间，就能只显示我们的图标了

实际上UE4引擎节点蓝图里也有一个自带的**缩放节点”ScaleUVsByCenter“**
### **UV的旋转扭曲**
**可以用引擎的自带节点Rotator**来进行UV旋转
纹理的扭曲，我们需要一张噪波贴图，因为纹理坐标节点是决定我们如何采样纹理的，所以我们只要用一张噪波贴图来打乱纹理坐标节点，那么我们最后采样的纹理也会扰乱。
我们把纹理坐标采样与噪波贴图相加，就可以看到最后采样的贴图被扭曲成异种随机的样式。我们可以增加一个平移节点，可以让我们的UV扭曲动起来![[v2-f3dabc4e56e59f02def6784443753be7_720w.webp]]
## **极坐标**
在UE4中的材质蓝图中，自带一个极坐标“VectorToFtadialValue”节点。
极坐标的UV
![[v2-efa2dfc54845753c111acfef0cdbbe04_720w.webp]]
## **向量与点积的运用：**
如果我们用相机向量去点乘一个顶点法向，会得到一个类似菲涅尔效果：
我们知道相机的向量就是像素到相机的方向，而顶点法向是顶点的法线朝向，根据我们之前学到的向量的点乘：向量方向相同，结果大于零，向量互相垂直则结果为0。那么我们可以看到材质预览窗口中，球的中心位置是大于0的，那么说明顶点的法线朝向与像素到相机的方向相同。而球的边缘时黑的，这个时候则顶点法线朝向与像素到相机的方向是垂直的。

上面我们得到了类似判断边缘的遮罩，但是我们的菲涅效果是边缘白色内部白色的。，所以我们可以直接上一个反向并且再加一个Power节点控制范围大小，之后链接钳制之后再使用线性插值混合两个颜色，就得到了我们典型的菲涅尔效果。![[v2-b63d541ff1d4df5222c191aa885acb4e_720w.webp]]我们可以使用像素法向替换掉顶点法向再加上一张法线贴图，就会得到一张非常高细节的菲涅尔效果：![[v2-f4749b45c0609ebe24a6667ba08d7f9c_720w.webp]]