## [参考链接](https://zhuanlan.zhihu.com/p/470949422)

# 官方文档
[UInputMappingContext | Epic Developer Community (epicgames.com)](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/EnhancedInput/UInputMappingContext?application_version=5.2)
# 定义
增强输入框架就是**改进一些过往问题的新答案**。它以模块化的方式解耦了从输入的按键配置到事件处理的逻辑处理过程，提供了更灵活和更便利的输入配置和处理功能。
# 旧输入系统
[[UE4--旧输入系统]]
# 核心概念
·
![[Pasted image 20231016115949.jpg]]
- 以前Action只能是FName, 现在是InputAction,可以保存更多信息（修改器、触发器)
### 输入操作(Input Actions):  IA

- FInputActionValue: 玩家的按键输入会映射到代码中的FInputActionValue 变量类型支持设置多种类型，可以为Bool或Float等
- 可以添加触发器(Triggers)和修改器(Modifiers)对FInputActionValue的变化规则和值的后处理更改进行一些定制。
### 输入映射上下文(Input Mapping Contexts):  IMC
- 应用场景：某个按钮既可以用来打开场景中的门，又可以用来拾取背包中的道具。
- 通过InputMappingContexts，当角色靠近门时，你可以添加"开门"这个上下文。假如角色打开背包，你可以添加"选择道具"这个输入映射上下文，并且让它的优先级高于"开门"
- 可以通过 增强输入本地玩家子系统（Enhanced Input Local Player Subsystem）将一个或多个上下文应用到本地玩家身上，并调整它们的优先级
- 这样做有助于确保不合适的输入动作无法运行，从而优化并预防bug。此外，使用互斥的输入映射上下文还有助于避免输入冲突，因此当某个用户输入用于不同的输入动作时，该输入绝不会意外触发错误的操作。
![[屏幕截图 2023-10-16 115640.png]]
### UPlayerMappableInputConfig: PMI
- 比IMC更高层的配置，可以配置多个IMC及其优先级，让输入配置进一步模块化。
### 修饰器(InputModifiers):  IM
- 输入修饰器是一种预处理器，能够修改UE5接收到的原始输入值，然后再将其发送给输入触发器（Input Trigger）。增强输入插件随附多种输入修饰器，可以执行各种任务，例如更改轴顺序、实现"死区"、将轴输入转换为世界空间以及其他功能。
- 可以自己写修饰器
![[Pasted image 20231016124049.jpg]]
#### 拌合输入轴值
[用人话讲！虚幻引擎 UE5 拌合输入轴值_酥妃大魔王i的博客-CSDN博客](https://blog.csdn.net/u011254268/article/details/131438314)
拌合输入轴值就是把键盘的'W''S'输入的Axis1D值放置在Axis2D的Y轴,这样没有加入拌和输入轴值的'A''D'就为X轴,输入值就从Axis1D值变为Axis2D的值
### 触发器(Triggers):
- 输入触发器用于确定用户输入在经过输入修饰器的处理后，是否会激活输入映射上下文中的输入动作。大部分输入触发器都会分析输入本身，检查最小动作值并验证各种模式
- 输入触发器有三种类型：
	- **显式（Explicit）** 类型将导致输入在输入触发器成功时成功。
	- **隐式（Implicit）** 类型将导致输入仅在输入触发器和所有其他隐式类型输入触发器都成功时成功。
	- **阻碍（Blocker）** 类型将导致输入在输入触发器成功时失败。
- 处理用户输入后，输入触发器可能返回三种状态之一：
	- **无（None）** 表明未满足输入触发器的条件，因此输入触发器失败。
	- **持续（Ongoing）** 表明部分满足了输入触发器的条件，并且输入触发器正在处理，但尚未成功。
	- **已触发（Triggered）** 表明已满足输入触发器的所有条件，因此输入触发器成功。
- 可以通过扩展输入触发器基类，即 **Input Trigger Timed Base** ，来创建自己的输入触发器。**Input Trigger Timed Base** 会检查输入是否已被按住一段时间，如是，则接受该输入并返回 **持续（Ongoing）** 状态。Input Trigger Timed Base永远不会返回 **已触发（Triggered）** 状态。在新建的输入触发器子类覆盖该函数，来确定它如何响应用户输入。函数 **Get Trigger Type** 将确定输入触发器的类型。**更新状态（Update State）** 将接受玩家的输入对象、当前输入动作值、增量时间，并返回 **无（None）** 、**持续（Ongoing）** 或 **已触发（Triggered）** 状态。

	下移 ： 即按下 按下后将持续触发 —— 对于线性按键可以指定阈值（按下多少大距离触发）
	
	已按下 ： 同上！ 不过 按下后只触发一次
	
	已松开 ： 松开按键时 触发一次
	
	弦操作 ： 当另一个 输入动作 触发时 才能 通过按键触发当前动作（持续触发） —— 例如 移动 的时候才能 奔跑
	
	点按 ： 必须在指定时间内松开按键才会 触发一次 —— 可以设置具体松开时间 阈值
	
	组合 ： 弦操作的Plus版本 ，可以指定 另外数个动作不同阶段 在触发或者非触发状态下才能 通过按键触发当前动作。 例如只能在 没有移动 的情况下 蹲下
	
	脉冲 ： 当长按时 以一定时间间隔触发 ，例如 实现每隔0.2秒触发一次 最多触发 n 次 | PS：如果单击的话将触发一次
	
	长按 ： 嗯！长按时候持续触发 可以设置长按多久触发
	
	长按和松开 ： 在长按后 松开时候 触发一次

### 为什么IMC和IA都有Triggers和Modifiers？
- 一个操作配置在IA里面相当于是全局的，如果两个都配了，两个都起作用，先是IMC里的起作用，再是IA里起作用。
- **（IA全局 IMC当前）**
### 蓝图中
![[Pasted image 20231111114010.png]]
![[Pasted image 20231111113943.png]]