``` cpp
void line(int x0, int y0, int x1, int y1, TGAImage& image, TGAColor color) {
    // 循环遍历从 x0 到 x1 的所有 x 坐标。
    for (int x = x0; x <= x1; x++) {
        // 计算当前 x 坐标与 x0 之间的比例 t。
        // 这与之前解释的线性插值计算相同。
        float t = (x - x0) / (float)(x1 - x0);

        // 使用线性插值计算对应的 y 坐标。
        // 这意味着根据 t 的值，在 y0 和 y1 之间插值得到 y。
        int y = y0 * (1 - t) + y1 * t;

        // 在图像上设置颜色，即在 (x, y) 坐标处绘制颜色。
        image.set(x, y, color);
    }
}
```

`float t = (x - x0) / (float)(x1 - x0);`
	`(float)(x1 - x0)` 是一个类型转换，确保除法操作是浮点除法。这是因为如果 `x0` 和 `x1` 都是整数，那么 `(x1 - x0)` 的结果也将是整数，而整数除法会==舍去小数部分==。通过将 `(x1 - x0)` 转换为 `float` 类型，可以保证得到一个精确的浮点结果。

#算法 Bresenham 算法
1. **初始化**：确定直线的起点 `(x0, y0)` 和终点 `(x1, y1)`，并计算直线的初始参数。
2. **计算初始决策参数**：决策参数（通常称为 `p`）用于确定在每一步中是选择当前像素的右侧还是上方像素。计算公式为 `p = 2 * Δy - Δx`，其中 `Δy = y1 - y0` 和 `Δx = x1 - x0`。
3. **迭代绘制像素**：从起点开始，沿着 x 轴方向（从 x0 到 x1）迭代，在每个步骤中：
    - 如果 `p >= 0`，选择当前像素的右侧和上方的像素 `(x, y+1)`，然后更新 `p = p + 2 * Δy - 2 * Δx`。
    - 如果 `p < 0`，选择当前像素的右侧像素 `(x+1, y)`，然后更新 `p = p + 2 * Δy`。
4. **绘制像素**：在每一步迭代中，使用选择的像素 `(x, y)` 并在图像上绘制。