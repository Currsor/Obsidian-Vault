## 基础

1. C和 C++ 的区别
	1.  C++是**面向对象**的的编程语言，C是面向过程的编程语言
	2. C++中的内存分配运算符是**new/delete**,而C 中是**malloc和free**
	3. C++中有**函数重载**,而C 中没有
	4. C++中新增了**引用**的概念,而C 中只有值和指针

2. struct与class的区别

| **特性**         | `struct`       | `class`       |
| ---------- | -------------- | ------------- |
| **默认访问权限** | public（适合数据聚合） | private（适合封装） |
| **默认继承方式** | public         | private       |
| **设计意图**   | 描述数据结构（如C兼容代码） | 封装对象（如面向对象设计） |
| **大括号初始化** | 支持（无构造函数时）     | 仅限public成员时支持 |
| **模板参数**   | 不支持            | 支持            |

3.  [define与const, typedef, inline区别](define与const,%20typedef,%20inline区别.md)

4. new/delete与malloc/free的区别

5. 指针与引用的区别

|**特性**|**指针**|**引用**|
|---|---|---|
|**本质**|存储地址的变量|变量的别名（底层为 `const` 指针）|
|**初始化**|可延迟初始化|必须立即初始化|
|**空值**|可为 `nullptr`|不可为空|
|**可变性**|可重新指向其他对象|绑定后不可更改|
|**内存占用**|占用独立内存（4/8 字节）|无额外内存消耗|
|**访问方式**|需解引用（`*`）|直接操作目标变量|
|**安全性**|需防野指针/空指针|需防悬空引用|
|**函数参数**|显式传递地址|隐式传递别名|
|**常量类型**|支持多级常量修饰|仅支持常量引用|
|**典型用途**|动态内存、数据结构、低级操作|函数参数、返回值优化|

6. 深拷贝与浅拷贝的区别

7. 移动构造函数与拷贝构造函数区别

|**特性**|**拷贝构造函数**|**移动构造函数**|
|---|---|---|
|**资源处理**|深拷贝，独立副本|直接转移资源，原对象失效|
|**参数类型**|`const T&`|`T&&`|
|**性能**|较高开销（复制数据）|低开销（仅转移指针）|
|**适用对象**|左值或需保留的原对象|右值或可销毁的临时对象|
|**原对象状态**|保持不变|被置为无效（如 `nullptr`）|

8. 重写与重载区别

| **特性**         | **重载（Overload）**             | **重写（Override）**                             |
| -------------- | ---------------------------- | -------------------------------------------- |
| **作用域**        | 同一类或作用域内（如一个类内部） <br>        | 基类与派生类之间（继承关系） <br>                          |
| **参数要求**       | 函数名相同，参数列表**必须不同**（类型、数量、顺序） | 函数名、参数列表、返回类型**必须相同** <br>                   |
| **virtual关键字** | 不需要（与虚函数无关） <br>             | 基类函数必须有`virtual`，派生类可加`override`（C++11） <br> |
| **多态类型**       | 编译时多态（静态绑定）                  | 运行时多态（动态绑定，通过虚函数表）                           |
| **目的**         | 提供同名函数的不同实现，处理不同参数类型 <br>    | 派生类定制基类行为，实现多态 <br>                          |

9. 内联函数与宏定义区别
- **内联函数**：
	是C++引入的一种特殊函数，使用`inline`关键字声明 
	编译器在编译阶段将函数调用处直接替换为函数体代码，避免函数调用的开销 
	本质上是真正的函数，遵循函数的所有规则 
- **宏定义**：
	是预处理指令，使用`#define`定义 
	预处理器在编译前进行简单的文本替换 
	不是真正的函数，只是代码片段的替换

10. 数组和指针区别

11. 前置++与后置++的区别

12. 动态链接库和静态链接库的区别

- **静态链接库**
	**编译时链接**：库的代码在编译阶段被直接复制到最终的可执行文件中，生成一个独立的、自包含的二进制文件 
	**文件扩展名**：Linux下为`.a`，Windows下为`.lib`
- **动态链接库**
	**运行时链接**：程序运行时才加载库文件，可执行文件中仅包含库的引用信息（如函数名和路径） 
	**文件扩展名**：Linux下为`.so`，Windows下为`.dll`

13. 关键字：static、const、extern、volatile作用
- static
	- 修饰局部变量
		生命周期：整个程序运行期间
		作用域：仍限于函数内部
		初始化：只在第一次执行时初始化
	- 修饰全局变量/函数
		作用域：限制在当前文件
		链接属性：内部链接（不可被其他文件extern引用）
	- 修饰类成员
		所有对象共享同一份拷贝
		静态成员函数无this指针，只能访问静态成员
		静态成员变量必须在类外单独初始化
- const
	const对象只能调用const成员函数
	非const对象可以调用const和非const成员函数
- extern
	- **声明变量/函数在其他文件中定义**
	- **实现跨文件共享**
- volatile
	- **防止编译器优化对变量的访问**
	- **确保每次访问都从内存读取**

13. 源文件从文本到可执行文件经历的过程

14. 四种类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast

## 面向对象

1. 面向对象的三大特性：封装、继承、多态

2. 类的访问权限：public、private、protected

3. 虚函数实现动态多态的原理

4. 虚函数与纯虚函数的区别

5. 类的构造函数、析构函数、拷贝函数、赋值函数

6. 动态多态、静态多态

## 内存

1. 内存布局（全局区、堆区、栈区、常量区、代码区）

2. 内存管理，指针、野指针、内存泄露

3. 如何判断内存泄漏，怎么避免

4. malloc的原理

## STL

1. 容器的实现原理，如 vector、deque、map、hashmap

2. vector与list对比

3. map与unordered_map对比

4. set与unordered_set对比

5. set和map实现原理

6. vector迭代器

## C++11新特征

1. 四种智能指针原理

2. 智能指针底层实现：auto_ptr、unique_ptr、shared_ptr、weak_ptr

3. shared_ptr中的循环引用

4. 可变参数模板

5. 右值引用

6. lambda