---
banner: "![[friendly-robot-colossusep2-00000.jpg]]"
banner_y: 0.78667
---
# 重心坐标（Barycentric Coordinates）
三角形间的插值
1. 为什么我们需要进行插值？
	指定顶点出的值
	获取三角形上平滑变化的值
2. 我们要插值什么？
	Texture coordinates，颜色，normal......
3. 我们如何进行插值？
	**重心坐标（Barycentric Coordinates）**

![[Pasted image 20241218135342.png]]
$$\left(x,y\right)=\alpha A+\beta B+\gamma C$$$$\alpha+\beta+\gamma=1$$
如果点在三角形内则三个坐标都是非负的
![[Pasted image 20241218135952.png]]
三个坐标可以通过面积比获得
$$\alpha = \frac{A_A}{A_A + A_B + A_C}$$
$$\beta = \frac{A_B}{A_A + A_B + A_C}$$
$$\gamma = \frac{A_C}{A_A + A_B + A_C}$$

重心是将三角形三等分的位置，即 $\alpha=\beta=\gamma=\frac{1}{3}$ 
![[Pasted image 20241218140547.png]]

- **对于三维空间中的点，不能保证其被投影后的重心坐标不变**
	如果想插值三维空间中的属性，就应该插值三维空间中的坐标。
	因为在做光栅化时，需要知道像素中心在三角形的什么位置，此时不能直接求重心坐标进行插值
	需要将该点重新投影回三维空间中，在三维空间中计算重心坐标插值

# 应用纹理
屏幕上的采样点（x,y）可以用重心坐标算出在纹理中采样的UV，得到对应纹理

## 纹理放大
当低分辨率纹理应用到高分辨率的屏幕上，纹理就会被拉大。
![[Pasted image 20241220174535.png]]
### Nearest
Nearest（最近）：将一个Texel映射到多个Pixel，形成了一个个像素点。
### Bilinear
Bilinear（双线性插值） 
![[Pasted image 20241220175446.png]]
Linear interpolation (1D):
$$lerp(x,v_0,v_1)=v_0+x(v_1-v_0)$$
Two helper lerps:
$$u_0=lerp(s,u_{00},u_{10}$$
$$u_1=lerp(s,u_{01},u_{11})$$
Final vertical lerp, to get result:
$$f\left ( x,y \right )=\mathrm{lerp}\left ( t,u_{0},u_{1} \right )$$
### Bicubic
双三次插值（Bicubic interpolation）是一种更高级的图像缩放技术，它考虑了待插值像素周围一个 $4\times4$ 的像素区域，而不是像双线性插值那样只考虑一个 $2\times2$ 的区域。双三次插值通常可以提供更平滑和更少的锯齿边缘的图像缩放效果。
# 纹理缩小
![[Pasted image 20241220182948.png]]
如果直接简单的使用线性插值进行采样会得到右图，远处有摩尔纹近处有锯齿
远处的一个像素就会覆盖很大一片的纹理区域，单纯以像素的中心是标准取纹理的值是不对的
这其实就是转变为了采样率不足的问题，之前解决采样率不足的问题我们可以使用SSAA，每个像素内分为若干小像素进行采样。

以512个小像素为例，得到的结果如下图
![[Pasted image 20241220183019.png]]
正确，但花费了512倍的性能

既然采样有问题，那我们如果可以直接查询而不采样呢？
## Mipmap
“Mip”源自拉丁语“multum in parvo”，意为在狭小的空间中包含众多
只可以进行近似的正方形查询
![[Pasted image 20241220183214.png]]

将原纹理提前用滤波处理得到很多更小的图像，当物体远离相机时，直接查询较小的纹理，得到正确的结果像素
Mipmap就可以实现我们需要的查询，但仅仅是近似的、正方形的查询

因为生成了多个较小的图像，需要额外储存生成的小图像
- 所以Mipmap占用的额外空间是原来的1/3

这是一种典型的空间换时间的思想
![[Pasted image 20241220183405.png]]

- 要查询在屏幕空间内的某像素，映射在纹理空间内占多大区域
	可以将自己中心和邻居的中心分别投影到纹理空间内，这样就能知道在纹理空间中，该点和邻居点之间的距离L，要求的区域可以近似为以L为边长的正方形区域
	![[Pasted image 20241221145901.png]]

但是会出现不连续的纹理映射，因为查的纹理都是整数层，比如我们无法直接查询1.5层的Mipmap
![[Pasted image 20241221145935.png]]
所以我们再进行一次插值：Trilinear Interpolation（三线性插值）
![[Pasted image 20241221145953.png]]
![[Pasted image 20241221150053.png]]
## 各向异性过滤
运用上述Mipmap后，在远处产生的图像很模糊，因为Mipmap是近似的、正方形的查询
只能查询正方形区域，而且三线性插值也是近似
![[Pasted image 20241221150149.png]]
屏幕上的像素映射到纹理上不一定是正方形，对于不是正方形的Mipmap就无法处理。

如下图，对于右边不是正方形但是是比较规则的矩形，我们可以用其他方法提供查询
![[Pasted image 20241221150211.png]]
将原图宽度不变长度压缩，长度不变宽度压缩就可以提供矩形的查找，即为各向异性过滤

经常看到的各向异性过滤x2x4等，指的是要生成多少层的压缩图，x2就是一层，x4就是两层。占用的空间逐渐向三倍靠拢
![[Pasted image 20241221150244.png]]
但各向异性过滤也只是能解决映射在纹理空间是比较规则的矩形的情况，当出现不规则矩形的时候也无法处理
![[Pasted image 20241221150303.png]]
所以又引出了**EWA过滤**，EWA过滤可以将任意形状拆分为很多大小不同的椭圆，经过多次查询，就能查询出最终的结果。

但是代价也是需要多次查询的时间
___
# [[Lecture 10]]